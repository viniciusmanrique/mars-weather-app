/**
 * Based on **`[Pause and resume setInterval](https://stackoverflow.com/a/42240115/10246377)`**.
 * `IntervalTimer` is a class that handles logic for intervals, e.g. start
 * stop, reset, resume, pause & maximum amount of fires.
 */
/// <reference types="node" />
import { TAnyFunction } from '../typings/definitions';
export declare enum EState {
    IDLE = 0,
    RUNNING = 1,
    PAUSED = 2,
    RESUME = 3
}
export interface IIntervalTimer {
    callback: TAnyFunction;
    state: EState;
    remaining: number;
    interval: number;
    fires: number;
    maxFires?: number;
    pausedTime: number | Date;
    lastTimeFired: Date;
    timerId: NodeJS.Timeout | number;
    resumeId: NodeJS.Timeout | number;
    lastPauseTime: Date;
}
declare class IntervalTimer implements IIntervalTimer {
    callback: TAnyFunction;
    interval: number;
    maxFires?: number;
    state: EState;
    remaining: number;
    fires: number;
    pausedTime: number | Date;
    lastTimeFired: Date;
    timerId: NodeJS.Timeout | number;
    resumeId: NodeJS.Timeout | number;
    lastPauseTime: Date;
    constructor(callback: TAnyFunction, interval: number, maxFires?: number | undefined);
    /**
     * `proxyCallback` handles the callback execution, the amount
     * of fires, & the times when fired.
     * If `this.maxFires` is **not** null, and it's bigger than
     * `this.fires` and if `this.fires` exists, meaning if it the
     * interval was at least started once before, then never fire again.
     */
    private proxyCallback;
    /**
     * `start` executes the interval, and saves the interval ID for further use.
     * The time of execution is also fired in case it's paused later on. The state
     * is finally set as running.
     */
    start: () => void;
    /**
     * `stop` clears every respective timeout and interval, then sets the state as idle.
     */
    stop: () => void;
    /**
     * Resets the interval.
     */
    reset: () => void;
    /**
     * `pause` tries to mimic pausing the interval by calculating the remaining time and storing it
     * in a member variable. Afterwards clear the respective timeout and interval then set the new
     * state.
     */
    pause: () => void;
    /**
     * `resume` calculates the remaining time for the callback to trigger using the values
     * set by `paused`. Will execute a new `setTimeout` while passing the `remaining` time
     * as the timeout delay.
     */
    resume: () => void;
    /**
     * `timeoutCallback` is executed by `resume`. `timeoutCallback` is the
     * callback of a new `setTimeout` executed by `resume` to mimic a resume
     * function.
     * We execute the callback by running `proxyCallback`, and then `start`
     * is executed to run a new interval.
     */
    private timeoutCallback;
    /**
     * Set a new interval to use on the next interval loop.
     */
    setInterval: (newInterval: number) => void;
    /**
     * Maximum amount of times the `callback` member will execute, it's infinite by default.
     */
    setMaxFires: (newMax: number) => void;
}
export default IntervalTimer;
